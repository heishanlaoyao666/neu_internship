---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by admin.
--- DateTime: 2022/6/10 15:57
---

local cBlockArray={

    ---***
    --- *   形状
    {
        {
            {1,1,1,0},
            {0,1,0,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {1,1,0,0},
            {0,1,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {0,1,1,0},
            {0,1,0,0},
            {0,0,0,0},
        },
    },
    ---**
    ---**   形状
    {
        {
            {0,1,1,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0},
        },

    },
    --- **
    ---**   形状
    {
        {
            {0,1,1,0},
            {1,1,0,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {0,1,1,0},
            {0,0,1,0},
            {0,0,0,0},
        },

    },
    --- *
    ---**
    ---*   形状
    {
        {
            {1,1,0,0},
            {0,1,1,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,0,1,0},
            {0,1,1,0},
            {0,1,0,0},
            {0,0,0,0},
        },

    },
    ---*
    ---*
    ---*
    ---*   形状
    {
        initOffset=1,
        {
            {0,0,0,0},
            {1,1,1,1},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,1,0,0},
        },

    },
    ---*
    ---*
    ---**形状
    {
        initOffset=1,
        {
            {0,0,0,0},
            {1,1,1,0},
            {1,0,0,0},
            {0,0,0,0},
        },
        {
            {1,1,0,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,0,0,0},
        },
        {
            {0,0,1,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {0,1,1,0},
            {0,0,0,0},
        },

    },
    --- *
    ---***形状
    {
        initOffset=1,
        {
            {0,0,0,0},
            {1,1,1,0},
            {0,0,1,0},
            {0,0,0,0},
        },
        {
            {0,1,0,0},
            {0,1,0,0},
            {1,1,0,0},
            {0,0,0,0},
        },
        {
            {1,0,0,0},
            {1,1,1,0},
            {0,0,0,0},
            {0,0,0,0},
        },
        {
            {0,1,1,0},
            {0,1,0,0},
            {0,1,0,0},
            {0,0,0,0},
        },

    },
}

local Block = class("Block")

---初始位置
local InitXOffset = cSceneWidth/2 - 3


function RandomStyle()
    return math.random(1, #cBlockArray)
end


function Block:ctor(scene, index)
    self.x = InitXOffset
    self.y = cSceneHeight
    --矩阵第一行是否有方块，保证方块贴着顶部生成
    local offset = cBlockArray[index].initOffset
    if offset then
        self.y = self.y + offset
    end
    self.scene = scene
    self.index = index
    self.trans = math.random( 1,#cBlockArray[index])
end

local function IterateBlock(index, trans, callback)

    local transArray = cBlockArray[index]

    local eachBlock = transArray[trans]
    for y = 1, #eachBlock do
        local xdata = eachBlock[y]
        for x = 1, #xdata do
            local data = xdata[x]
            if not callback(x, y, data ~= 0) then
                return false
            end
        end
    end
    return true
end
function RawPlace(index, trans, scene, newX, newY)
    local result = {}

    if IterateBlock(index, trans, function(x, y, b)
        if b then
            local finalX = newX + x
            local finalY = newY - y
            if scene:Get(finalX, finalY) then
                return false
            end
            table.insert(result, {x = finalX, y = finalY})
        end
        return true
    end) then
        for k, v in pairs(result) do
            scene:Set(v.x, v.y, true)
        end
        return true
    end

end

function Block:Move(deltaX, deltaY)
    self:Clear()
    local x = self.x + deltaX
    local y = self.y + deltaY
    if RawPlace(self.index, self.trans, self.scene, x, y) then
        self.x = x
        self.y = y
        return true
    else
        self:Place()
        return false
    end
end

function Block:zRotate()
    local offset = cBlockArray[self.index].initOffset
    if offset and self.y == 0 then
        return
    end
    self:Clear()
    local transArray = cBlockArray[self.index]
    local trans = self.trans -1
    if trans < 1 then
        trans = #transArray
    end
    if RawPlace(self.index, trans, self.scene, self.x, self.y) then
        self.trans = trans
    else
        self:Place()
    end
end

function Block:yRotate()
    local offset = cBlockArray[self.index].initOffset
    if offset and self.y == 0 then
        return
    end
    self:Clear()
    local transArray = cBlockArray[self.index]
    local trans = self.trans + 1
    if trans > #transArray then
        trans = 1
    end
    if RawPlace(self.index, trans, self.scene, self.x, self.y) then
        self.trans = trans
    else
        self:Place()
    end
end
function Block:Place()
    return RawPlace(self.index, self.trans, self.scene, self.x, self.y)
end
function Block:Clear()
    IterateBlock(self.index, self.trans, function(x, y, b)
        local finalX = self.x + x
        local finalY = self.y - y
        if b then
            self.scene:Set(finalX, finalY, false)
        end
        return true
    end)
end
return Block